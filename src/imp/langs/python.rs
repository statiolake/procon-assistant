use super::Lang;
use super::{FilesToOpen, MinifyMode, Preprocessed, Progress, RawSource, Result};
use anyhow::Context;
use anyhow::{anyhow, bail};
use scopefunc::ScopeFunc;
use std::fs as stdfs;
use std::path::{Path, PathBuf};
use std::process::Command;

pub struct Python;

impl Lang for Python {
    fn check() -> bool {
        Path::new("main.py").exists()
    }

    fn new_boxed() -> Box<dyn Lang> {
        Box::new(Python)
    }

    fn lang_name() -> &'static str {
        "python"
    }

    fn get_source(&self) -> Result<RawSource> {
        stdfs::read_to_string(Path::new("main.py"))
            .map(RawSource)
            .map_err(Into::into)
    }

    fn init_async(&self) -> Progress<anyhow::Result<()>> {
        Progress::from_fn(move |sender| {
            let _ = sender.send("creating main.py".into());
            let path_main = Path::new("main.py");
            if !path_main.exists() {
                stdfs::write(path_main, "").context("failed to create main.py")?;
            }

            let _ = sender.send("generating Visual Studio Code settings".into());
            stdfs::create_dir_all(Path::new(".vscode")).context("failed to create .vscode dir")?;
            stdfs::write(
                Path::new(".vscode").join("settings.json"),
                r#"{ "isProconProject": true }"#,
            )
            .context("failed to create Visual Studio Code settings")?;

            Ok(())
        })
    }

    fn to_open(&self) -> FilesToOpen {
        FilesToOpen {
            files: vec![PathBuf::from("main.py")],
            directory: PathBuf::from("."),
        }
    }

    fn open_docs(&self) -> Result<()> {
        bail!("TODO: Currently no documentation prepared for Python")
    }

    fn needs_compile(&self) -> bool {
        // Python does not need compilation
        false
    }

    fn needs_release_compile(&self) -> bool {
        // Release mode always needs compile
        true
    }

    fn compile_command(&self) -> Result<Vec<Command>> {
        // No need to compile
        Ok(vec![])
    }

    fn release_compile_command(&self) -> Result<Vec<Command>> {
        let py = get_python()?;
        Ok(vec![Command::new(py).modify(|c| {
            c.arg("main.py").arg("ONLINE_JUDGE");
        })])
    }

    fn run_command(&self) -> Result<Command> {
        // Remove pyd file (which is generated by AOT compile)
        let pyds = glob::glob("*.pyd").unwrap();
        for pyd in pyds {
            pyd.map_err(anyhow::Error::from)
                .and_then(|pyd| stdfs::remove_file(pyd).map_err(anyhow::Error::from))
                .context("failed to remove AOT compiled .pyd files")?;
        }

        let py = get_python()?;
        Ok(Command::new(py).modify(|c| {
            c.arg("main.py");
        }))
    }

    fn release_run_command(&self) -> Result<Command> {
        let py = get_python()?;
        Ok(Command::new(py).modify(|c| {
            c.arg("main.py");
        }))
    }

    fn preprocess(&self, source: &RawSource, _minify: MinifyMode) -> Result<Preprocessed> {
        let RawSource(raw) = source;
        Ok(Preprocessed(raw.clone()))
    }

    fn lint(&self, _source: &RawSource) -> Result<Vec<String>> {
        Ok(vec![])
    }
}

fn get_python() -> Result<PathBuf> {
    which::which("python3")
        .or_else(|_| which::which("python"))
        .map_err(|_| anyhow!("failed to find python3 in your environment."))
}
