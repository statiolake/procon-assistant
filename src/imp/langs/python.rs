use super::Lang;
use super::{FilesToOpen, MinifyMode, Preprocessed, Progress, RawSource, Result};
use anyhow::Context;
use anyhow::{anyhow, bail};
use scopefunc::ScopeFunc;
use std::fs as stdfs;
use std::path::{Path, PathBuf};
use std::process::Command;

pub struct Python;

impl Lang for Python {
    fn check() -> Result<bool> {
        Ok(Path::new("main.py").exists())
    }

    fn new_boxed() -> Result<Box<dyn Lang>> {
        Ok(Box::new(Python))
    }

    fn lang_name() -> &'static str {
        "python"
    }

    fn get_source(&self) -> Result<RawSource> {
        stdfs::read_to_string(Path::new("main.py"))
            .map(RawSource)
            .map_err(Into::into)
    }

    fn init_async(&self, path: &Path) -> Progress<anyhow::Result<()>> {
        let path_project = path.to_path_buf();
        Progress::from_fn(move |sender| {
            let _ = sender.send("creating main.py".into());
            let path_main = path_project.join("main.py");
            if !path_main.exists() {
                stdfs::write(path_main, "").context("failed to create main.py")?;
            }

            let _ = sender.send("generating Visual Studio Code settings".into());
            stdfs::create_dir_all(path_project.join(".vscode"))
                .context("failed to create .vscode dir")?;
            stdfs::write(
                path_project.join(".vscode").join("settings.json"),
                r#"{ "isProconProject": true }"#,
            )
            .context("failed to create Visual Studio Code settings")?;

            Ok(())
        })
    }

    fn to_open(&self, path: &Path) -> Result<FilesToOpen> {
        Ok(FilesToOpen {
            files: vec![path.join("main.py")],
            directory: path.to_path_buf(),
        })
    }

    fn open_docs(&self) -> Result<()> {
        bail!("TODO: Currently no documentation prepared for Python")
    }

    fn needs_compile(&self) -> Result<bool> {
        // Python does not need compilation
        Ok(false)
    }

    fn needs_release_compile(&self) -> Result<bool> {
        // Release mode always needs compile
        Ok(true)
    }

    fn compile_command(&self) -> Result<Vec<Command>> {
        // No need to compile
        Ok(vec![])
    }

    fn release_compile_command(&self) -> Result<Vec<Command>> {
        let py = get_python()?;
        Ok(vec![Command::new(py).modify(|c| {
            c.arg("main.py").arg("ONLINE_JUDGE");
        })])
    }

    fn run_command(&self) -> Result<Command> {
        // Remove pyd file (which is generated by AOT compile)
        let pyds = glob::glob("*.pyd").unwrap();
        for pyd in pyds {
            pyd.map_err(anyhow::Error::from)
                .and_then(|pyd| stdfs::remove_file(pyd).map_err(anyhow::Error::from))
                .context("failed to remove AOT compiled .pyd files")?;
        }

        let py = get_python()?;
        Ok(Command::new(py).modify(|c| {
            c.arg("main.py");
        }))
    }

    fn release_run_command(&self) -> Result<Command> {
        let py = get_python()?;
        Ok(Command::new(py).modify(|c| {
            c.arg("main.py");
        }))
    }

    fn preprocess(&self, source: &RawSource, _minify: MinifyMode) -> Result<Preprocessed> {
        let RawSource(raw) = source;
        Ok(Preprocessed(raw.clone()))
    }

    fn lint(&self, _source: &RawSource) -> Result<Vec<String>> {
        Ok(vec![])
    }
}

fn get_python() -> Result<PathBuf> {
    which::which("python3")
        .or_else(|_| which::which("python"))
        .map_err(|_| anyhow!("failed to find python3 in your environment."))
}
